<!doctype html>
<html lang="tr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>ATO ‚Äì Dijital Labirent (Demo)</title>
    <style>
        :root {
            --bg: #0b1020;
            --text: rgba(255, 255, 255, 0.92);
            --muted: rgba(255, 255, 255, 0.7);
            --card: rgba(255, 255, 255, 0.07);
            --border: rgba(255, 255, 255, 0.10);
            --shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
            --radius: 18px;

            --good: #37d67a;
            --bad: #ff4d6d;
            --accent: #7aa7ff;

            /* Labirent renkleri */
            --mazeBase: #000000;
            --mazeWall: #1f66ff;
            --mazeBorder: #6a0dad;
            /* Mor √áer√ßeve */
            --mazePath: #000000;
            --mazeGrid: rgba(255, 255, 255, 0.06);
            --checkpoint: #ffd166;
            --player: #ffffff;
            --exit: #37d67a;
            --start: #7aa7ff;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
            background: radial-gradient(1200px 700px at 20% 20%, rgba(122, 167, 255, 0.18), transparent 60%),
                radial-gradient(900px 600px at 80% 30%, rgba(55, 214, 122, 0.12), transparent 55%),
                radial-gradient(900px 600px at 30% 90%, rgba(255, 77, 109, 0.10), transparent 55%),
                var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 18px;
        }

        .app {
            width: min(1100px, 100%);
            display: grid;
            grid-template-columns: 1.25fr 0.75fr;
            gap: 16px;
        }

        @media (max-width: 900px) {
            .app {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.05));
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        header {
            padding: 16px 18px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .title {
            display: grid;
            gap: 4px;
        }

        .title h1 {
            margin: 0;
            font-size: 18px;
        }

        .title p {
            margin: 0;
            font-size: 13px;
            color: var(--muted);
            line-height: 1.25;
        }

        .pill {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.85);
            background: rgba(122, 167, 255, 0.18);
            border: 1px solid rgba(122, 167, 255, 0.30);
            padding: 8px 10px;
            border-radius: 999px;
            white-space: nowrap;
        }

        .content {
            padding: 14px 18px 18px;
            display: grid;
            gap: 12px;
        }

        .row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .stepText {
            font-weight: 750;
            font-size: 15px;
        }

        .progress {
            flex: 1;
            height: 10px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .progress>div {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, rgba(122, 167, 255, 0.85), rgba(55, 214, 122, 0.85));
            border-radius: 999px;
            transition: width 260ms ease;
        }

        .mazeWrap {
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.10);
            border-radius: var(--radius);
            padding: 12px;
            display: grid;
            gap: 10px;
        }

        .mazeTop {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            color: var(--muted);
            font-size: 12px;
            line-height: 1.2;
        }

        .dot {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(255, 255, 255, 0.06);
            color: rgba(255, 255, 255, 0.82);
        }

        .sw {
            width: 10px;
            height: 10px;
            border-radius: 999px;
            display: inline-block;
        }

        canvas {
            width: 100%;
            height: auto;
            border-radius: 14px;
            background: var(--mazeBase);
            border: 10px solid var(--mazeBorder);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.10);
            touch-action: none;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            align-items: center;
            justify-items: center;
        }

        button {
            appearance: none;
            border: 0;
            border-radius: 14px;
            padding: 12px 12px;
            font-size: 16px;
            font-weight: 800;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            transition: transform 80ms ease, opacity 120ms ease;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.10);
            color: rgba(255, 255, 255, 0.92);
            width: 100%;
            max-width: 180px;
        }

        button:active {
            transform: scale(0.98);
        }

        button.secondary {
            background: rgba(122, 167, 255, 0.14);
            border-color: rgba(122, 167, 255, 0.25);
        }

        button.danger {
            background: rgba(255, 77, 109, 0.12);
            border-color: rgba(255, 77, 109, 0.25);
        }

        .feedback {
            padding: 12px 14px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.10);
            background: rgba(255, 255, 255, 0.06);
            font-size: 14px;
            line-height: 1.3;
            color: rgba(255, 255, 255, 0.86);
            min-height: 46px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .tag {
            font-size: 12px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(255, 255, 255, 0.06);
            color: rgba(255, 255, 255, 0.82);
            white-space: nowrap;
        }

        /* Modal (Zarf/Soru) */
        .modalOverlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.55);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 16px;
            z-index: 20;
        }

        .modalOverlay.active {
            display: flex;
        }

        .modal {
            width: min(720px, 100%);
            background: rgba(15, 20, 35, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 18px;
            box-shadow: 0 30px 70px rgba(0, 0, 0, 0.45);
            overflow: hidden;
        }

        .modalHead {
            padding: 14px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.10);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .modalHead .h {
            display: grid;
            gap: 4px;
        }

        .modalHead .h b {
            font-size: 16px;
        }

        .modalHead .h span {
            font-size: 12px;
            color: var(--muted);
        }

        .modalBody {
            padding: 16px;
            display: grid;
            gap: 12px;
        }

        .qText {
            font-size: 18px;
            line-height: 1.35;
            font-weight: 850;
        }

        .hint {
            font-size: 13px;
            color: var(--muted);
            line-height: 1.35;
        }

        .btnRow {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 4px;
        }

        .btnGood {
            background: rgba(55, 214, 122, 0.18);
            border: 1px solid rgba(55, 214, 122, 0.38);
        }

        .btnBad {
            background: rgba(255, 77, 109, 0.16);
            border: 1px solid rgba(255, 77, 109, 0.36);
        }

        /* Right panel */
        .right {
            padding: 16px 18px 18px;
            display: grid;
            gap: 12px;
        }

        .box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.10);
            border-radius: var(--radius);
            padding: 14px;
            display: grid;
            gap: 10px;
        }

        .nodes {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
        }

        .node {
            height: 44px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.10);
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 850;
            color: rgba(255, 255, 255, 0.78);
        }

        .node.done {
            background: rgba(55, 214, 122, 0.14);
            border-color: rgba(55, 214, 122, 0.30);
            color: rgba(255, 255, 255, 0.92);
        }

        .node.current {
            outline: 2px solid rgba(122, 167, 255, 0.70);
            background: rgba(122, 167, 255, 0.16);
            border-color: rgba(122, 167, 255, 0.28);
            color: rgba(255, 255, 255, 0.95);
        }

        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.70);
            line-height: 1.35;
        }

        /* SCREENS */
        .screen {
            display: none;
            width: 100%;
            height: 100%;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            animation: fadeIn 0.4s ease;
        }

        .screen.active {
            display: flex;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .heroTitle {
            font-size: 32px;
            font-weight: 800;
            background: linear-gradient(135deg, #fff 0%, #7aa7ff 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 16px;
        }

        .heroText {
            font-size: 16px;
            color: var(--muted);
            max-width: 480px;
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .bigBtn {
            font-size: 18px;
            padding: 16px 32px;
            background: var(--accent);
            color: #0b1020;
            border: none;
            box-shadow: 0 10px 20px rgba(122, 167, 255, 0.3);
        }

        .bigBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 14px 28px rgba(122, 167, 255, 0.4);
        }

        /* NEW: Input & Timer Styles */
        .nameInput {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 14px 20px;
            font-size: 18px;
            color: white;
            margin-bottom: 20px;
            text-align: center;
            width: 240px;
            outline: none;
            transition: 0.2s;
        }

        .nameInput:focus {
            border-color: var(--accent);
            background: rgba(255, 255, 255, 0.15);
        }

        .timerDisplay {
            font-family: ui-monospace, monospace;
            font-size: 20px;
            font-weight: bold;
            color: var(--accent);
            background: rgba(122, 167, 255, 0.1);
            padding: 6px 12px;
            border-radius: 8px;
            border: 1px solid rgba(122, 167, 255, 0.2);
            display: inline-block;
            min-width: 80px;
            text-align: center;
        }

        .leaderboard {
            margin-top: 24px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 20px;
            width: 100%;
            max-width: 400px;
            text-align: left;
        }

        .leaderboard h3 {
            margin-bottom: 12px;
            color: var(--accent);
            text-align: center;
        }

        .lb-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 15px;
        }

        .lb-row:last-child {
            border-bottom: none;
        }

        .lb-rank {
            color: var(--muted);
            width: 24px;
        }

        .lb-name {
            flex: 1;
            font-weight: 600;
        }

        .lb-time {
            font-family: monospace;
        }

        .current-score {
            font-size: 24px;
            margin: 10px 0 24px;
            font-weight: bold;
            color: #4cd964;
        }
    </style>
</head>

<body>
    <!-- 1) START SCREEN -->
    <div id="startScreen" class="screen active">
        <h1 class="heroTitle">ATO ‚Äì Dijital Labirent</h1>
        <p class="heroText">
            Afet bilincini artƒ±rmak i√ßin hazƒ±rlanmƒ±≈ü bu sim√ºlasyonda;
            doƒüru kararlar vererek hedefe ula≈ümalƒ±sƒ±n.
        </p>
        <input type="text" id="playerName" class="nameInput" placeholder="Adƒ±nƒ±z Soyadƒ±nƒ±z" maxlength="20">
        <button class="bigBtn" onclick="startGame()">OYUNA BA≈ûLA</button>
    </div>

    <!-- 2) GAME SCREEN (Mevcut Oyun) -->
    <div id="gameScreen" class="screen">
        <div class="app">
            <!-- LEFT -->
            <section class="panel">
                <header>
                    <div class="title">
                        <h1>ATO ‚Äì Dijital Labirent (Demo)</h1>
                        <p>Ta≈üƒ± labirentte ilerlet, zarf noktalarƒ±nda sorularƒ± cevapla. Yanlƒ±≈üta √ßƒ±kmaza girip geri d√∂n.
                        </p>
                    </div>
                    <div class="pill" id="modePill">Hazƒ±r</div>
                    <div class="timerDisplay" id="timerDisplay">00:00</div>
                </header>

                <div class="content">
                    <div class="row">
                        <div class="stepText" id="stepText">Zarf 1 / 10</div>
                        <div class="progress">
                            <div id="progressBar"></div>
                        </div>
                    </div>

                    <div class="mazeWrap">
                        <div class="mazeTop">
                            <div class="legend">
                                <span class="dot"><span class="sw" style="background:var(--player)"></span>Ta≈ü</span>
                                <span class="dot"><span class="sw"
                                        style="background:var(--checkpoint)"></span>Zarf</span>
                                <span class="dot"><span class="sw" style="background:var(--start)"></span>Giri≈ü</span>
                                <span class="dot"><span class="sw" style="background:var(--exit)"></span>√áƒ±kƒ±≈ü</span>
                            </div>
                            <button class="secondary" onclick="resetGame()">üîÅ Ba≈ütan</button>
                        </div>

                        <canvas id="maze" width="600" height="900"></canvas>

                        <!-- Touch controls -->
                        <div class="controls">
                            <div></div>
                            <button onclick="move(0,-1)">‚¨ÜÔ∏è</button>
                            <div></div>
                            <button onclick="move(-1,0)">‚¨ÖÔ∏è</button>
                            <button onclick="move(0,1)">‚¨áÔ∏è</button>
                            <button onclick="move(1,0)">‚û°Ô∏è</button>
                        </div>
                    </div>

                    <div class="feedback" id="feedbackBox">
                        <span id="feedbackText">Ok tu≈ülarƒ±yla veya butonlarla ta≈üƒ± hareket ettir. Zarf noktasƒ±na gelince
                            soru a√ßƒ±lƒ±r.</span>
                        <span class="tag" id="feedbackTag">ATO</span>
                    </div>

                    <div class="mono">
                        Kƒ±sayollar: <b>‚Üë ‚Üì ‚Üê ‚Üí</b> hareket ‚Ä¢ <b>R</b> reset
                    </div>
                </div>
            </section>

            <!-- RIGHT -->
            <aside class="panel">
                <div class="right">
                    <div class="box">
                        <b>Zarf ƒ∞lerlemesi</b>
                        <div class="nodes" id="nodes"></div>
                        <div class="hint">
                            Sƒ±radaki zarf: <b id="nextLabel">1</b>. Sadece sƒ±radaki zarf aktif.
                        </div>
                    </div>

                    <div class="box">
                        <b>Oyun Kurallarƒ± (Rapor 2.6)</b>
                        <div class="hint" style="display:grid; gap:8px;">
                            <span>1. Her yol ayrƒ±mƒ±nda y√∂nlendirici zarflar bulunur.</span>
                            <span>2. Doƒüru cevabƒ±n altƒ±ndaki ok y√∂n√ºne (a√ßƒ±lan yola) hareket edilir.</span>
                            <span>3. Yanlƒ±≈ü cevapta √ßƒ±kmaz sokaƒüa girilir; geri d√∂n√ºp soruya tekrar bakƒ±lmalƒ±dƒ±r.</span>
                            <span>4. Duvarlarƒ±n √ºst√ºnden ge√ßilemez.</span>
                        </div>
                        <div class="mono">
                            Labirent ≈üekli <b>MAZE</b> dizisinden deƒüi≈ütirilebilir. Zarf noktalarƒ± <b>CHECKPOINTS</b>
                            ile
                            ayarlanƒ±r.
                        </div>
                    </div>
                </div>
            </aside>
        </div>
    </div>

    <!-- 3) END SCREEN -->
    <div id="endScreen" class="screen">
        <h1 class="heroTitle">Tebrikler! üéâ</h1>
        <p class="heroText">
            Labirenti ba≈üarƒ±yla tamamladƒ±n ve t√ºm afet sorularƒ±nƒ± doƒüru cevapladƒ±n.
            <br><br>
        <div class="current-score" id="finalScore">S√ºren: 00:00</div>
        <i>"Afetlere kar≈üƒ± bilin√ßli olmak hayat kurtarƒ±r."</i>
        </p>
        <button class="bigBtn" onclick="resetGameApp()">TEKRAR OYNA</button>

        <div class="leaderboard">
            <h3>üèÜ Liderlik Tablosu (Bu Cihaz)</h3>
            <div id="lbList">
                <!-- JS will populate -->
            </div>
        </div>
    </div>

    <!-- QUESTION MODAL -->
    <div class="modalOverlay" id="modal">
        <div class="modal" role="dialog" aria-modal="true">
            <div class="modalHead">
                <div class="h">
                    <b id="modalTitle">Zarf 1</b>
                    <span>Doƒüru/yanlƒ±≈ü cevap ver. Yanlƒ±≈üta √ßƒ±kmaza gidip geri d√∂nersin.</span>
                </div>
                <div class="pill" id="modalPill">Soru</div>
            </div>
            <div class="modalBody">
                <div class="qText" id="qText">‚Ä¶</div>
                <div class="hint" id="qHint">Cevabƒ±nƒ± se√ß.</div>
                <div class="btnRow">
                    <button class="btnGood" onclick="answer(true)">‚úÖ DOƒûRU</button>
                    <button class="btnBad" onclick="answer(false)">‚ùå YANLI≈û</button>
                </div>
                <button class="danger" onclick="closeModal()">Kapat</button>
            </div>
        </div>
    </div>

    <script>
        // =========================
        // SORULAR (ATO Labirent Oyun ƒ∞√ßi Sorularƒ±.pdf) + CEVAP ANAHTARI
        // Cevaplar: 1Y,2Y,3D,4Y,5D,6Y,7D,8D,9D,10Y
        // correct: DOƒûRU ise true, YANLI≈û ise false
        // =========================
        const QUESTIONS = [
            { text: "T√ºrkiye'de √ßƒ±ƒü felaketinin en fazla ya≈üandƒ±ƒüƒ± b√∂lge Akdeniz B√∂lgesidir.", correct: false }, // 1 Yanlƒ±≈ü
            { text: "Karadeniz B√∂lgesi'nde en yaygƒ±n g√∂r√ºlen afet t√ºr√º kuraklƒ±ktƒ±r.", correct: false },          // 2 Yanlƒ±≈ü
            { text: "Ege ve Akdeniz kƒ±yƒ±larƒ±nda orman yangƒ±nlarƒ± daha yaygƒ±n g√∂r√ºl√ºr.", correct: true },        // 3 Doƒüru
            { text: "Deprem √ßantasƒ±nda okuma kitabƒ± bulunmalƒ±dƒ±r.", correct: false },                           // 4 Yanlƒ±≈ü
            { text: "T√ºrkiye'de en fazla √ßƒ±ƒü felaketi g√∂ren b√∂lgemiz Doƒüu Anadolu B√∂lgesidir.", correct: true },// 5 Doƒüru
            { text: "T√ºrkiye'de orman yangƒ±nlarƒ±nƒ±n ya≈üanmasƒ±nda en sƒ±k g√∂r√ºlen neden yoƒüun n√ºfuslu b√∂lgelerin olmasƒ±dƒ±r.", correct: false }, // 6 Yanlƒ±≈ü
            { text: "Kuraklƒ±ƒüƒ±n olu≈üumunda ≈üiddetli buharla≈üma ve yaƒüƒ±≈ü miktarƒ±nda d√º≈ü√º≈ü etkili olmu≈ütur.", correct: true }, // 7 Doƒüru
            { text: "Marmara B√∂lgesi'nde en riskli afet t√ºr√º depremdir.", correct: true },                      // 8 Doƒüru
            { text: "K√ºresel ƒ±sƒ±nma kuraklƒ±klarƒ±n artmasƒ±na neden olur.", correct: true },                       // 9 Doƒüru
            { text: "Hortum, T√ºrkiye'de ya≈üanmaz.", correct: false },                                           // 10 Yanlƒ±≈ü
        ];

        // =========================
        // 2) LABƒ∞RENT HARƒ∞TASI (Fiziksel Modele Benzer)
        // 21 s√ºtun x 31 satƒ±r (Yakla≈üƒ±k)
        // 1=Duvar, 0=Yol
        // =========================
        const MAZE_STR = [
            "111111111111111111111", // 0 
            "100000000001000000001", // 1 (Exit at 18,1)
            "101111111101011111101", // 2
            "101000000000010000001", // 3 (CP 10 around here)
            "101011111111110111111", // 4
            "101010000000000000001", // 5
            "101010111111111111101", // 6 (CP 9)
            "101010000010000000001", // 7
            "101011111010111111101", // 8
            "101000001010000000001", // 9 (CP 8)
            "101111101011111111101", // 10
            "100000001000000000001", // 11
            "101111111111111111101", // 12
            "100000000000000000001", // 13 (CP 5? 6?)
            "111111111111110111111", // 14
            "100000000000010000001", // 15
            "101111111011010111101", // 16
            "101000001010010100001", // 17 (CP 4)
            "101011101110110101111", // 18
            "101010000000100101001", // 19
            "101010111111101101011", // 20
            "101010000000000000001", // 21 (CP 3)
            "101011111111111111101", // 22
            "101000000000000000001", // 23
            "101111111101111111101", // 24
            "100000000101000000001", // 25 (CP 1, 2)
            "111111110101011111101", // 26
            "100000010101010000001", // 27
            "101111010101010111101", // 28
            "100000000100000100001", // 29 (Start area)
            "111111111101111111111", // 30 (Entrance at 10)
        ];

        const MAZE = MAZE_STR.map(r => r.split('').map(c => parseInt(c)));

        // Giri≈ü / √áƒ±kƒ±≈ü
        const START = { x: 10, y: 29 };
        const EXIT = { x: 18, y: 1 };

        // =========================
        // 3) ZARF NOKTALARI (10 adet)
        // ƒ∞deal rotaya g√∂re sƒ±ralƒ± yerle≈üim
        // =========================
        const CHECKPOINTS = [
            { id: 1, x: 14, y: 29 }, // Giri≈ü saƒüƒ±
            { id: 2, x: 5, y: 27 },  // Sol k√∂≈üe
            { id: 3, x: 13, y: 25 }, // Orta saƒü
            { id: 4, x: 5, y: 23 },  // Sol yukarƒ±sƒ±
            { id: 5, x: 17, y: 21 }, // Saƒü kenar
            { id: 6, x: 9, y: 17 },  // Orta
            { id: 7, x: 3, y: 13 },  // Sol √ºst
            { id: 8, x: 13, y: 9 },  // Orta √ºst
            { id: 9, x: 5, y: 5 },   // Sol en √ºst
            { id: 10, x: 12, y: 3 }, // √áƒ±kƒ±≈üa yakƒ±n
        ];

        // =========================
        // GAME STATE
        // =========================
        let expectedCheckpoint = 1;   // sƒ±radaki zarf
        let solved = new Set();       // doƒüru cevaplanan zarflar
        let player = { x: START.x, y: START.y };
        let lastSafe = { x: START.x, y: START.y }; // yanlƒ±≈üta buraya d√∂nd√ºr
        let modalOpen = false;

        // Canvas setup
        const canvas = document.getElementById("maze");
        const ctx = canvas.getContext("2d");

        // UI refs
        const modalEl = document.getElementById("modal");
        const qTextEl = document.getElementById("qText");
        const modalTitleEl = document.getElementById("modalTitle");
        const modePillEl = document.getElementById("modePill");
        const modalPillEl = document.getElementById("modalPill");

        const feedbackTextEl = document.getElementById("feedbackText");
        const feedbackTagEl = document.getElementById("feedbackTag");

        const nodesEl = document.getElementById("nodes");
        const stepTextEl = document.getElementById("stepText");
        const progressBarEl = document.getElementById("progressBar");
        const nextLabelEl = document.getElementById("nextLabel");

        // Grid sizing
        const rows = MAZE.length;
        const cols = MAZE[0].length;
        const cell = Math.floor(Math.min(canvas.width / cols, canvas.height / rows));
        const offsetX = Math.floor((canvas.width - cols * cell) / 2);
        const offsetY = Math.floor((canvas.height - rows * cell) / 2);

        // Helpers
        function setFeedback(msg, tag = "ATO") {
            feedbackTextEl.textContent = msg;
            feedbackTagEl.textContent = tag;
        }

        function inBounds(x, y) {
            return y >= 0 && y < rows && x >= 0 && x < cols;
        }

        function isWall(x, y) {
            if (!inBounds(x, y)) return true;
            return MAZE[y][x] === 1;
        }

        function isCheckpointCell(x, y) {
            return CHECKPOINTS.find(c => c.x === x && c.y === y);
        }

        // RENKLER (Mobil uyumluluk i√ßin JS i√ßine sabitlendi)
        const COLORS = {
            bg: "#0b1020",
            mazeBase: "#000000",
            mazeWall: "#1f66ff",
            mazePath: "#000000",
            checkpoint: "#ffd166",
            player: "#ffffff",
            exit: "#37d67a",
            start: "#7aa7ff",
            solved: "rgba(55,214,122,0.85)",
            locked: "rgba(255,209,102,0.35)"
        };

        function draw() {
            // base
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // background
            ctx.fillStyle = COLORS.mazeBase;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // draw walls
            ctx.fillStyle = COLORS.mazeWall;
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (MAZE[y][x] === 1) {
                        ctx.fillRect(offsetX + x * cell, offsetY + y * cell, cell, cell);
                    }
                }
            }

            // start / exit tiles
            drawTile(START.x, START.y, COLORS.start);
            drawTile(EXIT.x, EXIT.y, COLORS.exit);

            // checkpoints
            for (const cp of CHECKPOINTS) {
                const isSolved = solved.has(cp.id);
                const isNext = (cp.id === expectedCheckpoint);
                // solved -> green tint, next -> yellow, locked -> dim
                let color = COLORS.checkpoint;
                if (isSolved) color = COLORS.solved;
                else if (!isNext) color = COLORS.locked;
                drawTile(cp.x, cp.y, color);

                // number
                ctx.fillStyle = "rgba(0,0,0,0.75)";
                ctx.font = `${Math.max(12, Math.floor(cell * 0.45))}px system-ui`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(String(cp.id), offsetX + cp.x * cell + cell / 2, offsetY + cp.y * cell + cell / 2);
            }

            // player
            const px = offsetX + player.x * cell + cell / 2;
            const py = offsetY + player.y * cell + cell / 2;
            ctx.beginPath();
            ctx.fillStyle = COLORS.player;
            ctx.arc(px, py, Math.max(6, Math.floor(cell * 0.28)), 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = "rgba(0,0,0,0.35)";
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawTile(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(offsetX + x * cell, offsetY + y * cell, cell, cell);
        }

        function updateProgressUI() {
            const total = QUESTIONS.length;
            stepTextEl.textContent = `Zarf ${Math.min(expectedCheckpoint, total)} / ${total}`;
            nextLabelEl.textContent = String(expectedCheckpoint);
            const pct = Math.round(((expectedCheckpoint - 1) / total) * 100);
            progressBarEl.style.width = pct + "%";
            modePillEl.textContent = modalOpen ? "Zarf A√ßƒ±ldƒ±" : "Labirent";
            renderNodes();
        }

        function renderNodes() {
            nodesEl.innerHTML = "";
            for (let i = 1; i <= QUESTIONS.length; i++) {
                const div = document.createElement("div");
                div.className = "node";
                div.textContent = i;
                if (solved.has(i)) div.classList.add("done");
                if (i === expectedCheckpoint) div.classList.add("current");
                nodesEl.appendChild(div);
            }
        }

        // Movement
        function move(dx, dy) {
            if (modalOpen) return;

            const nx = player.x + dx;
            const ny = player.y + dy;
            if (isWall(nx, ny)) {
                setFeedback("‚õî Duvar var. Duvarlarƒ±n √ºst√ºnden ge√ßemezsin.", "KURAL");
                return;
            }
            player.x = nx;
            player.y = ny;

            // reached exit?
            if (player.x === EXIT.x && player.y === EXIT.y) {
                if (solved.size === QUESTIONS.length) {
                    setFeedback("üéâ √áƒ±kƒ±≈üa ula≈ütƒ±n ve t√ºm zarflarƒ± doƒüru yaptƒ±n!", "√áIKI≈û");
                } else {
                    setFeedback("üö™ √áƒ±kƒ±≈ü burada ama √∂nce t√ºm zarflarƒ± √ß√∂zmelisin.", "√áIKI≈û");
                }
            } else {
                setFeedback("Ta≈üƒ± ilerlet. Sƒ±radaki zarfƒ± bul.", "ATO");
            }

            // checkpoint trigger
            const cp = isCheckpointCell(player.x, player.y);
            if (cp && cp.id === expectedCheckpoint) {
                openQuestion(cp.id);
            }

            draw();
        }

        // Modal question logic
        function openQuestion(id) {
            modalOpen = true;
            modalEl.classList.add("active");
            modalTitleEl.textContent = `Zarf ${id}`;
            qTextEl.textContent = QUESTIONS[id - 1]?.text ?? "(Soru yok)";
            modalPillEl.textContent = "Soru";
            updateProgressUI();
            setFeedback(`üì© Zarf ${id} a√ßƒ±ldƒ±. Soruyu cevapla.`, "ZARF");
        }

        function closeModal() {
            modalOpen = false;
            modalEl.classList.remove("active");
            updateProgressUI();
            draw();
        }

        function answer(userAnswer) {
            if (!modalOpen) return;

            const id = expectedCheckpoint;
            const q = QUESTIONS[id - 1];
            const correct = q.correct;

            if (userAnswer === correct) {
                solved.add(id);
                lastSafe = { x: player.x, y: player.y }; // artƒ±k bu checkpoint g√ºvenli
                expectedCheckpoint++;

                modalPillEl.textContent = "Doƒüru!";
                setFeedback("‚úÖ Doƒüru! Ok y√∂n√ºnde (a√ßƒ±lan yolda) ilerle.", "ƒ∞LERLE");

                // If finished all
                if (expectedCheckpoint > QUESTIONS.length) {
                    // setFeedback("üéâ √áƒ±kƒ±≈üa ula≈ütƒ±n!", "Bƒ∞Tƒ∞≈û");
                    // expectedCheckpoint = QUESTIONS.length + 1;
                    endGameSuccess();
                }

                // close modal after short delay
                setTimeout(() => {
                    closeModal();
                    updateProgressUI();
                    draw();
                }, 450);
            } else {
                modalPillEl.textContent = "Yanlƒ±≈ü!";
                setFeedback("‚ùå Yanlƒ±≈ü cevap! √áƒ±kmaz sokaƒüa girdin. Geri d√∂n ve tekrar dene.", "√áIKMAZ");

                // teleport back to last safe
                setTimeout(() => {
                    player.x = lastSafe.x;
                    player.y = lastSafe.y;
                    closeModal();
                    updateProgressUI();
                    draw();
                }, 1500); // give more time to read 'Wrong'
            }
        }

        function resetGame() {
            expectedCheckpoint = 1;
            solved = new Set();
            player = { x: START.x, y: START.y };
            lastSafe = { x: START.x, y: START.y };
            modalOpen = false;
            modalEl.classList.remove("active");
            setFeedback("Ba≈üladƒ±k. Ta≈üƒ± labirentte ilerlet, Zarf 1'i bul.", "ATO");
            updateProgressUI();
            draw();
        }

        // Keyboard
        window.addEventListener("keydown", (e) => {
            const k = e.key.toLowerCase();
            if (k === "r") resetGame();
            if (k === "arrowup") move(0, -1);
            if (k === "arrowdown") move(0, 1);
            if (k === "arrowleft") move(-1, 0);
            if (k === "arrowright") move(1, 0);
        });

        // init - Start screen is active by default in HTML

        // TIMER & STATE
        let startTime = 0;
        let timerInterval = null;
        let currentPlayerName = "Misafir";

        function startGame() {
            const input = document.getElementById("playerName");
            let name = input.value.trim();
            if (!name) {
                alert("L√ºtfen bir isim giriniz!");
                return;
            }
            currentPlayerName = name;
            showScreen("gameScreen");
            resetGame();

            // Start Timer
            startTime = Date.now();
            clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
            updateTimer();
        }

        function updateTimer() {
            const now = Date.now();
            const diff = Math.floor((now - startTime) / 1000);
            const m = Math.floor(diff / 60).toString().padStart(2, '0');
            const s = (diff % 60).toString().padStart(2, '0');
            document.getElementById("timerDisplay").textContent = `${m}:${s}`;
        }

        function stopTimer() {
            clearInterval(timerInterval);
            return document.getElementById("timerDisplay").textContent;
        }

        function endGameSuccess() {
            const finalTimeStr = stopTimer();
            saveScore(currentPlayerName, finalTimeStr);

            document.getElementById("finalScore").textContent = `S√ºren: ${finalTimeStr}`;
            renderLeaderboard();
            showScreen("endScreen");
        }

        // Leaderboard (LocalStorage)
        const LB_KEY = "ATO_LABIRENT_LB";

        function saveScore(name, timeStr) {
            // timeStr "MM:SS" -> seconds for sorting
            const [m, s] = timeStr.split(':').map(Number);
            const totalSeconds = m * 60 + s;

            let lb = JSON.parse(localStorage.getItem(LB_KEY) || "[]");
            lb.push({ name, timeStr, seconds: totalSeconds, date: new Date().toLocaleDateString() });

            // Sort by seconds (ascending)
            lb.sort((a, b) => a.seconds - b.seconds);

            // Keep top 10
            lb = lb.slice(0, 10);

            localStorage.setItem(LB_KEY, JSON.stringify(lb));
        }

        function renderLeaderboard() {
            const listEl = document.getElementById("lbList");
            listEl.innerHTML = "";

            let lb = JSON.parse(localStorage.getItem(LB_KEY) || "[]");
            if (lb.length === 0) {
                listEl.innerHTML = "<div class='mono' style='text-align:center'>Hen√ºz kayƒ±t yok.</div>";
                return;
            }

            lb.forEach((item, index) => {
                const row = document.createElement("div");
                row.className = "lb-row";
                row.innerHTML = `
                    <div class="lb-rank">#${index + 1}</div>
                    <div class="lb-name">${escapeHtml(item.name)}</div>
                    <div class="lb-time">${item.timeStr}</div>
                `;
                listEl.appendChild(row);
            });
        }

        function escapeHtml(text) {
            if (!text) return "";
            return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        function resetGameApp() {
            showScreen("startScreen");
            document.getElementById("playerName").value = ""; // clear input
        }

        function showScreen(id) {
            document.querySelectorAll(".screen").forEach(s => s.classList.remove("active"));
            document.getElementById(id).classList.add("active");
        }

        // IMPORTANT: iOS/Safari i√ßin fonksiyonlarƒ± global'e baƒüla
        window.move = move;
        window.resetGame = resetGame;
        window.answer = answer;
        window.closeModal = closeModal;
        window.startGame = startGame;
        window.resetGameApp = resetGameApp;

        // Auto-resize canvas on startup (optional fix for blurriness, but keeping simple for now)
    </script>

    </script>
</body>

</html>